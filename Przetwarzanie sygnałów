#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

void wczytywanie_wspolczynnikow(double tab_wspolczynniki[], int ilosc_wspolczynnikow);
void dziedzina(double* dziedzina_minimum, double* dziedzina_maksimum);
void generatorSinus(double tab_wspolczynniki[], double dziedzina_minimum, double dziedzina_maksimum, double tab_wartosci[], int* ilosc, double* rozdzielczosc);
void rozmiar_tablic(int* rozmiar_tablicy);
void zapisz(double* tab_wartosci, double* tab_szum_wlasciwa, int* rozmiar_tablicy);
void szum(double wyniki[], int rozmiar_tablicy, double wyniki_szumu[], double tab_szum_wlasciwa[]);

void sawSignal(float tab_wspolczynniki[], float dziedzina_minimum, float dziedzina_maksimum, float tab_wartosci[], int* ilosc, float* rozdzielczosc) {
	float coefficentA = tab_wspolczynniki[0];
	float coefficentB = tab_wspolczynniki[1];
	float waveLenght = tab_wspolczynniki[2];
	float currentValue = coefficentB;
	float amplitude = coefficentA;
	float j = 0;
	int i = 0;
	int x = 0;
	int y = 0;



	for (j = dziedzina_minimum; j <= (dziedzina_maksimum - dziedzina_minimum) * (1 / (*rozdzielczosc)); j = j + 1) {
		*(tab_wartosci + i) = currentValue;
		*ilosc = (*ilosc) + 1; //ilosc to ilosc wynikow
		printf("%d, ", *ilosc);   //sprawdzenie ilosci zapelnionych komorek
		printf("j=%f,", j); // sprawdzenie jak sie j nalicza
		printf("  i=%d    wartosc to: %f  [%d]		granica=%f\n", i, currentValue, x, dziedzina_maksimum);
		x++;
		i++;
		currentValue = currentValue + *rozdzielczosc;
		if (currentValue > amplitude) {
			currentValue = coefficentB;
		}
	}
	*(tab_wartosci + i) = '\0';
}



int main() {
	double tab_wspolczynniki[4];
	int ilosc_wspolczynnikow = 4; //zmienic w zaleznosci od potrzeb

	/*
	WSPOLCZYNNIKI
	[0]-WSPOLCZYNNIK A- AMPLITUDA		A*sin(C*alfa+D)+B
	[1]-WSPOLCZYNNIK B
	[2]-CZESTOTLIWOSC
	[3]-FAZA
	*/

	double dziedzina_minimum;
	double dziedzina_maksimum;
	dziedzina(&dziedzina_minimum, &dziedzina_maksimum);								// FUNKCJA

	int rozmiar_tablicy;
	rozmiar_tablic(&rozmiar_tablicy);

	double rozdzielczosc = (fabs(dziedzina_minimum) + fabs(dziedzina_maksimum)) / rozmiar_tablicy;  //fabs zwraca wartosc bezwzgledna
	printf("rozdzielczosc to: %lf\n\n", rozdzielczosc);

	double* tab_wartosci = malloc(rozmiar_tablicy * sizeof(*tab_wartosci)); //float ma 4 bajty*rozmiar tablicy i przydzielamy malloc'iem to tab_wartosci
	double* tab_szum = malloc(rozmiar_tablicy * sizeof(*tab_wartosci));
	double* tab_szum_wlasciwa = malloc(rozmiar_tablicy * sizeof(*tab_wartosci));


	double* tab_odfiltrowane = malloc(rozmiar_tablicy * sizeof(*tab_wartosci));


	int ilosc_zapelnionych_komorek = 0;		//tutaj jest do liczenia zapelnionych komorek
	//wczytywanie_wspolczynnikow(tab_wspolczynniki, ilosc_wspolczynnikow);			//FUNKCJA

	tab_wspolczynniki[0] = 1;
	tab_wspolczynniki[1] = 0;
	tab_wspolczynniki[2] = 1;
	tab_wspolczynniki[3] = 0;

	//sawSignal(tab_wspolczynniki, dziedzina_minimum, dziedzina_maksimum, tab_wartosci, &ilosc_zapelnionych_komorek,&rozdzielczosc);				//FUNKCJA
	generatorSinus(tab_wspolczynniki, dziedzina_minimum, dziedzina_maksimum, tab_wartosci, &ilosc_zapelnionych_komorek, &rozdzielczosc);			//FUNKCJA
	szum(tab_wartosci, rozmiar_tablicy, tab_szum,tab_szum_wlasciwa);
	zapisz(tab_wartosci,tab_szum_wlasciwa, &rozmiar_tablicy);


	return 0;
}


//////////////  FUNKCJE  //////////////

void wczytywanie_wspolczynnikow(double tab_wspolczynniki[], int ilosc_wspolczynnikow) {
	int a = 0;
	int c;
	for (a; a < ilosc_wspolczynnikow; a++) {
		printf("Podaj %d wspolczynnik (A*sin(C*alfa+D)+B):", a + 1);
		while (scanf("%lf", tab_wspolczynniki + a) != 1) {
			printf("podaj prawidlowa liczbe!");
			while ((c = getchar()) != '\n' && c != EOF) {}
		}
	}

	/* for(a=0;a<ilosc_wspolczynnikow;a++){
	 printf("\n%d wspolczynnik to:%f",a+1,tab_wspolczynniki[a]);     //test
	 }*/

}

void dziedzina(double* dziedzina_minimum, double* dziedzina_maksimum)
{
	printf("Podaj dolna granice dziedziny: ");
	while (scanf("%lf", dziedzina_minimum) != 1) {
		printf("podaj prawidlowa liczbe!");
		int c;
		while ((c = getchar()) != '\n' && c != EOF) {}
	}
	//*dziedzina_minimum = (*dziedzina_minimum) * 10;

	printf("Podaj gorna granice dziedziny: ");
	do {
		while (scanf("%lf", dziedzina_maksimum) != 1) {
			printf("podaj prawidlowa liczbe!");
			int c;
			while ((c = getchar()) != '\n' && c != EOF) {}
		}
		//	*dziedzina_maksimum = (*dziedzina_maksimum) * 10;
		if (*dziedzina_maksimum > * dziedzina_minimum) {
			printf("dolna granica to:%lf\ngorna granica to:%lf\n\n\n", (*dziedzina_minimum), (*dziedzina_maksimum));
		}
		else { printf("gorna granica musi byc wieksza od dolnej!\nPodaj gorna granice dziedziny:"); }

	} while (*dziedzina_maksimum <= *dziedzina_minimum);
}

void generatorSinus(double wspolczynniki[], double dziedzina_minimum, double dziedzina_maksimum, double tab_wartosci[], int* ilosc, double* rozdzielczosc) {
	double parametrA = wspolczynniki[0]; //amplituda
	double parametrB = wspolczynniki[1];
	double parametrC = wspolczynniki[2]; //czestotliwosc
	double parametrD = wspolczynniki[3];
	double j;
	int i = 0;
	for (j = dziedzina_minimum; j < dziedzina_maksimum; j = j + *rozdzielczosc) {
		*(tab_wartosci + i) = parametrA * sinf((parametrC * j) + parametrD) + parametrB;  //j to jakby alfa
				//SPRAWDZENIA
		*ilosc = (*ilosc) + 1; //ilosc to ilosc wynikow, ile razy petla sie zrobila
		printf("%d, ", *ilosc);   //sprawdzenie ilosci zapelnionych komorek
		printf("j=%lf,", j); // sprawdzenie jak sie j nalicza
		printf("  i=[%d]    wartosc to: %lf	dziedzina=%lf \n", i, *(tab_wartosci + i), dziedzina_maksimum);	//*/
		i++;
	}
}

void rozmiar_tablic(int* rozmiar_tablicy)
{
	printf("Podaj liczbe elementow funkcji: ");
	scanf("%d", rozmiar_tablicy);
	while (*rozmiar_tablicy < 0 || *rozmiar_tablicy == 0)				// ZABEZPIECZENIA DOROBIC
	{
		printf("Wprowadziles niepoprawna liczbe podaj liczbe > 0. Liczba elementow funkcji: ");
		scanf("%d", rozmiar_tablicy);
	}
}

void zapisz(double* tab_wartosci, double* tab_szum_wlasciwa, int *rozmiar_tablicy) {
	FILE* plik;
	int j=0;

	plik = fopen("Wyniki.csv", "w");

	for (j; j < *rozmiar_tablicy; j++) {
		fprintf(plik, "%d;%lf;%lf,\n", j, tab_wartosci[j], tab_szum_wlasciwa[j]);
	}

	fclose(plik);
}

void szum(double wyniki[], int rozmiar_tablicy, double wyniki_szumu[], double tab_szum_wlasciwa[])
{
	srand(time(NULL));
	int liczba_zaszumionych;
	int max = (0.21 * rozmiar_tablicy);                  //gorna granica losowania
	int min = (0.1 * rozmiar_tablicy);                   //dolna granica losowania

	liczba_zaszumionych = (rand() % max + min);	// losuje od 0 do (max-1), a do tego dodaje wartosc min
	printf("Liczba zaszumionych probek = %d\n", liczba_zaszumionych);

	double amplituda;
	double najwieksza = wyniki[0];              //ustalamy, że największą wartością jest (póki co) pierwszy element tablicy
	double najmniejsza = wyniki[0];             //ustalamy, że najmniejszą wartością jest (póki co) pierwszy element tablicy

	for (int i = 0; i < rozmiar_tablicy; i++)         //szukanie amplitudy
	{
		if (wyniki[i] > najwieksza)
			najwieksza = wyniki[i];                 //jeśli sprawdzany element tablicy jest większy od tego (dotychczas) największego, to on staje się tym największym

		if (wyniki[i] < najmniejsza)
			najmniejsza = wyniki[i];               //jeśli sprawdzany element tablicy jest mniejszy od tego (dotychczas) najmniejszego, to on staje się tym najmniejszym
		//printf("wyniki: %lf\n", wyniki[i]);
	}

	amplituda = fabs(najwieksza) + fabs(najmniejsza);

	printf("Najwieksza wartosc funkcji to: %lf\n", najwieksza);
	printf("Najmniejsza wartosc funkcji to: %lf\n", najmniejsza);
	printf("Amplituda wynosi: %lf\n", amplituda);
	int x = 0;
	for (x; x < rozmiar_tablicy; x++) {
		tab_szum_wlasciwa[x] = wyniki[x];		//przerzucenie wynikow do drugiej tablicy, do ktorej potem jest dodawany szum
	}

	int i2;
	double wartosc_szumu;
	int max_szum = 31 * amplituda * 2;
	int min_szum = -31 * amplituda;
	int numer_tablicy;
	//printf("max_szum=%d, min_szum=%d\n", max_szum, min_szum);
	for (i2 = 0; i2 < liczba_zaszumionych; i2++)
	{
		numer_tablicy = (rand() % rozmiar_tablicy + 1);
		wartosc_szumu = (rand() % max_szum / 10. + min_szum / 10.);
		wyniki_szumu[numer_tablicy] = wartosc_szumu;
		//printf("wynik szumu:%lf\n", wyniki_szumu[numer_tablicy]);
		tab_szum_wlasciwa[numer_tablicy] = wyniki_szumu[numer_tablicy] + wyniki[numer_tablicy];	//dodanie szumu do tablicy
			//printf("wyniki po zaszumieniu to:%lf\n", tab_szum_wlasciwa[numer_tablicy]);
	}
	x = 0;
	for (x; x < rozmiar_tablicy; x++)
	{
		printf("wyniki ostateczne:%lf\n", tab_szum_wlasciwa[x]);
	}
}
