#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <locale.h>

void wczytywanie_wspolczynnikow(double tab_wspolczynniki[], int ilosc_wspolczynnikow);
void dziedzina(double* dziedzina_minimum, double* dziedzina_maksimum);
void generatorSinus(double tab_wspolczynniki[], double dziedzina_minimum, double dziedzina_maksimum, double tab_wartosci[], int* ilosc, double* rozdzielczosc);
void rozmiar_tablic(int* rozmiar_tablicy);
void zapisz(double* tab_wartosci, double* tab_szum_wlasciwa, int* rozmiar_tablicy, double* wyniki_po_sredniej);
void szum(double wyniki[], int rozmiar_tablicy, double wyniki_szumu[], double tab_szum_wlasciwa[]);
void filtr_srednia_ruchoma(double* tab_szum_wlasciwa, double* wyniki_po_sredniej, int rozmiar_tablicy);
void filtr_medianowy(double* tab_szum_wlasciwa, double* wyniki_po_medianowym, int rozmiar_tablicy);

void sawSignal(float tab_wspolczynniki[], float dziedzina_minimum, float dziedzina_maksimum, float tab_wartosci[], int* ilosc, float* rozdzielczosc) {
	float coefficentA = tab_wspolczynniki[0];
	float coefficentB = tab_wspolczynniki[1];
	float waveLenght = tab_wspolczynniki[2];
	float currentValue = coefficentB;
	float amplitude = coefficentA;
	float j = 0;
	int i = 0;
	int x = 0;
	int y = 0;



	for (j = dziedzina_minimum; j <= (dziedzina_maksimum - dziedzina_minimum) * (1 / (*rozdzielczosc)); j = j + 1) {
		*(tab_wartosci + i) = currentValue;
		*ilosc = (*ilosc) + 1; //ilosc to ilosc wynikow
		printf("%d, ", *ilosc);   //sprawdzenie ilosci zapelnionych komorek
		printf("j=%f,", j); // sprawdzenie jak sie j nalicza
		printf("  i=%d    wartosc to: %f  [%d]		granica=%f\n", i, currentValue, x, dziedzina_maksimum);
		x++;
		i++;
		currentValue = currentValue + *rozdzielczosc;
		if (currentValue > amplitude) {
			currentValue = coefficentB;
		}
	}
	*(tab_wartosci + i) = '\0';
}





int main() {
	setlocale(LC_ALL, "polish_poland");
	double tab_wspolczynniki[4];
	int ilosc_wspolczynnikow = 4; //zmienic w zaleznosci od potrzeb

	/*
	WSPOLCZYNNIKI
	[0]-WSPOLCZYNNIK A- AMPLITUDA		A*sin(C*alfa+D)+B
	[1]-WSPOLCZYNNIK B
	[2]-CZESTOTLIWOSC
	[3]-FAZA
	*/

	double dziedzina_minimum;
	double dziedzina_maksimum;
	dziedzina(&dziedzina_minimum, &dziedzina_maksimum);								// FUNKCJA

	int rozmiar_tablicy;
	rozmiar_tablic(&rozmiar_tablicy);		//wpisujemy rozmiar tablicy

	double rozdzielczosc = (fabs(dziedzina_minimum) + fabs(dziedzina_maksimum)) / rozmiar_tablicy;  //fabs zwraca wartosc bezwzgledna
	printf("rozdzielczosc to: %lf\n\n", rozdzielczosc);

	double* tab_wartosci = malloc(rozmiar_tablicy * sizeof(*tab_wartosci)); //float ma 4 bajty*rozmiar tablicy i przydzielamy malloc'iem to tab_wartosci
	double* tab_szum = malloc(rozmiar_tablicy * sizeof(*tab_wartosci));
	double* tab_szum_wlasciwa = malloc(rozmiar_tablicy * sizeof(*tab_wartosci));		//tutaj jest tablica wartosci, z dodanym szumem
	double* wyniki_po_sredniej = malloc(rozmiar_tablicy * sizeof(*wyniki_po_sredniej));
	double* wyniki_po_medianowym = malloc(rozmiar_tablicy * sizeof(*wyniki_po_medianowym));


	double* tab_odfiltrowane = malloc(rozmiar_tablicy * sizeof(*tab_wartosci));


	int ilosc_zapelnionych_komorek = 0;		//tutaj jest do liczenia zapelnionych komorek
	//wczytywanie_wspolczynnikow(tab_wspolczynniki, ilosc_wspolczynnikow);			//FUNKCJA

	tab_wspolczynniki[0] = 1;
	tab_wspolczynniki[1] = 0;
	tab_wspolczynniki[2] = 1;
	tab_wspolczynniki[3] = 0;

	//sawSignal(tab_wspolczynniki, dziedzina_minimum, dziedzina_maksimum, tab_wartosci, &ilosc_zapelnionych_komorek,&rozdzielczosc);				//FUNKCJA
	generatorSinus(tab_wspolczynniki, dziedzina_minimum, dziedzina_maksimum, tab_wartosci, &ilosc_zapelnionych_komorek, &rozdzielczosc);			//FUNKCJA
	szum(tab_wartosci, rozmiar_tablicy, tab_szum,tab_szum_wlasciwa);
	filtr_srednia_ruchoma(tab_szum_wlasciwa,wyniki_po_sredniej,rozmiar_tablicy);
	filtr_medianowy(tab_szum_wlasciwa, wyniki_po_medianowym, rozmiar_tablicy);
	zapisz(tab_wartosci,tab_szum_wlasciwa, &rozmiar_tablicy,wyniki_po_sredniej,wyniki_po_medianowym);


	return 0;
}


//////////////  FUNKCJE  //////////////

void wczytywanie_wspolczynnikow(double tab_wspolczynniki[], int ilosc_wspolczynnikow) {
	int a = 0;
	int c;
	for (a; a < ilosc_wspolczynnikow; a++) {
		printf("Podaj %d wspolczynnik (A*sin(C*alfa+D)+B):", a + 1);
		while (scanf("%lf", tab_wspolczynniki + a) != 1) {
			printf("podaj prawidlowa liczbe!");
			while ((c = getchar()) != '\n' && c != EOF) {}
		}
	}

	/* for(a=0;a<ilosc_wspolczynnikow;a++){
	 printf("\n%d wspolczynnik to:%f",a+1,tab_wspolczynniki[a]);     //test
	 }*/

}

void dziedzina(double* dziedzina_minimum, double* dziedzina_maksimum)
{
	printf("Podaj dolna granice dziedziny: ");
	while (scanf("%lf", dziedzina_minimum) != 1) {
		printf("podaj prawidlowa liczbe!");
		int c;
		while ((c = getchar()) != '\n' && c != EOF) {}
	}
	//*dziedzina_minimum = (*dziedzina_minimum) * 10;

	printf("Podaj gorna granice dziedziny: ");
	do {
		while (scanf("%lf", dziedzina_maksimum) != 1) {
			printf("podaj prawidlowa liczbe!");
			int c;
			while ((c = getchar()) != '\n' && c != EOF) {}
		}
		//	*dziedzina_maksimum = (*dziedzina_maksimum) * 10;
		if (*dziedzina_maksimum > * dziedzina_minimum) {
			printf("dolna granica to:%lf\ngorna granica to:%lf\n\n\n", (*dziedzina_minimum), (*dziedzina_maksimum));
		}
		else { printf("gorna granica musi byc wieksza od dolnej!\nPodaj gorna granice dziedziny:"); }

	} while (*dziedzina_maksimum <= *dziedzina_minimum);
}

void generatorSinus(double wspolczynniki[], double dziedzina_minimum, double dziedzina_maksimum, double tab_wartosci[], int* ilosc, double* rozdzielczosc) {
	double parametrA = wspolczynniki[0]; //amplituda
	double parametrB = wspolczynniki[1];
	double parametrC = wspolczynniki[2]; //czestotliwosc
	double parametrD = wspolczynniki[3];
	double j;
	int i = 0;
	for (j = dziedzina_minimum; j < dziedzina_maksimum; j = j + *rozdzielczosc) {
		*(tab_wartosci + i) = parametrA * sinf((parametrC * j) + parametrD) + parametrB;  //j to jakby alfa
				//SPRAWDZENIA
		*ilosc = (*ilosc) + 1; //ilosc to ilosc wynikow, ile razy petla sie zrobila
		/*printf("%d, ", *ilosc);   //sprawdzenie ilosci zapelnionych komorek
		printf("j=%lf,", j); // sprawdzenie jak sie j nalicza
		printf("  i=[%d]    wartosc to: %lf	dziedzina=%lf \n", i, *(tab_wartosci + i), dziedzina_maksimum);	//*/
		i++;
	}
}

void rozmiar_tablic(int* rozmiar_tablicy)
{
	printf("Podaj liczbe elementow funkcji: ");
	scanf("%d", rozmiar_tablicy);
	while (*rozmiar_tablicy < 0 || *rozmiar_tablicy == 0)				// ZABEZPIECZENIA DOROBIC
	{
		printf("Wprowadziles niepoprawna liczbe podaj liczbe > 0. Liczba elementow funkcji: ");
		scanf("%d", rozmiar_tablicy);
	}
}

void zapisz(double* tab_wartosci, double* tab_szum_wlasciwa, int *rozmiar_tablicy, double* wyniki_po_sredniej, double* wyniki_po_medianowym) {
	FILE* plik;
	int j=0;

	plik = fopen("Wyniki.CSV", "w");
	//printf("\n\n\ntab_wartosci[0]=%lf \nwyniki po sredniej[0]=%lf\n wyniki_po_medianowym[0]=%lf\n", tab_wartosci[0], wyniki_po_sredniej[0], wyniki_po_medianowym[0]);

	if (plik == NULL)
	{
		printf("Ups, cos nie dziala! Nie udalo sie otworzyc pliku CSV. Sprawdz kod i sprobuj zresetowac program\n");
	}

	if (wyniki_po_sredniej[0]==tab_wartosci[0] && wyniki_po_medianowym[0] != tab_wartosci[0]) {
		for (j; j < *rozmiar_tablicy; j++) {
			fprintf(plik, "%d;%lf;%lf;%lf\n", j, tab_wartosci[j], tab_szum_wlasciwa[j], wyniki_po_sredniej[j]);
		}
	}
	if (wyniki_po_medianowym[0] == tab_wartosci[0] && wyniki_po_sredniej[0] != tab_wartosci[0]) {
		for (j; j < *rozmiar_tablicy; j++) {
			fprintf(plik, "%d;%lf;%lf;;%lf\n", j, tab_wartosci[j], tab_szum_wlasciwa[j], wyniki_po_medianowym[j]);
		}
	}
	if (wyniki_po_sredniej[0] == tab_wartosci[0] && wyniki_po_medianowym[0] == tab_wartosci[0]) {
		for (j; j < *rozmiar_tablicy; j++) {
			fprintf(plik, "%d;%lf;%lf;%lf;%lf\n", j, tab_wartosci[j], tab_szum_wlasciwa[j], wyniki_po_sredniej[j], wyniki_po_medianowym[j]);
		}
	}
	else {
		for (j; j < *rozmiar_tablicy; j++) {
			fprintf(plik, "%d;%lf;%lf;%lf\n", j, tab_wartosci[j], tab_szum_wlasciwa[j], wyniki_po_medianowym[j]);
		}
		
	}
	fclose(plik);
}

void szum(double wyniki[], int rozmiar_tablicy, double wyniki_szumu[], double tab_szum_wlasciwa[])
{
	srand(time(NULL));
	int liczba_zaszumionych;
	int max = (0.21 * rozmiar_tablicy);                  //gorna granica losowania
	int min = (0.1 * rozmiar_tablicy);                   //dolna granica losowania

	liczba_zaszumionych = (rand() % max + min);	// losuje od 0 do (max-1), a do tego dodaje wartosc min
	printf("Liczba zaszumionych probek = %d\n", liczba_zaszumionych);

	double amplituda;
	double najwieksza = wyniki[0];              //ustalamy, że największą wartością jest (póki co) pierwszy element tablicy
	double najmniejsza = wyniki[0];             //ustalamy, że najmniejszą wartością jest (póki co) pierwszy element tablicy

	for (int i = 0; i < rozmiar_tablicy; i++)         //szukanie amplitudy
	{
		if (wyniki[i] > najwieksza)
			najwieksza = wyniki[i];                 //jeśli sprawdzany element tablicy jest większy od tego (dotychczas) największego, to on staje się tym największym

		if (wyniki[i] < najmniejsza)
			najmniejsza = wyniki[i];               //jeśli sprawdzany element tablicy jest mniejszy od tego (dotychczas) najmniejszego, to on staje się tym najmniejszym
		//printf("wyniki: %lf\n", wyniki[i]);
	}

	amplituda = fabs(najwieksza) + fabs(najmniejsza);

	printf("Najwieksza wartosc funkcji to: %lf\n", najwieksza);
	printf("Najmniejsza wartosc funkcji to: %lf\n", najmniejsza);
	printf("Amplituda wynosi: %lf\n", amplituda);
	int x = 0;
	for (x; x < rozmiar_tablicy; x++) {
		tab_szum_wlasciwa[x] = wyniki[x];		//przerzucenie wynikow do drugiej tablicy, do ktorej potem jest dodawany szum
	}

	int i2;
	double wartosc_szumu;
	int max_szum = 31 * amplituda * 2;
	int min_szum = -31 * amplituda;
	int numer_tablicy;
	//printf("max_szum=%d, min_szum=%d\n", max_szum, min_szum);
	//printf("\n\n\n\n\n\n");
	for (i2 = 0; i2 < liczba_zaszumionych; i2++)
	{
		numer_tablicy = (rand() % rozmiar_tablicy + 1);
		wartosc_szumu = (rand() % max_szum / 100. + min_szum / 100.);
		wyniki_szumu[numer_tablicy] = wartosc_szumu;
		//printf("wynik szumu:%lf\n", wyniki_szumu[numer_tablicy]);
		tab_szum_wlasciwa[numer_tablicy] = wyniki_szumu[numer_tablicy] + wyniki[numer_tablicy];	//dodanie szumu do tablicy
			//printf("\nwyniki po zaszumieniu to:%lf\n", tab_szum_wlasciwa[numer_tablicy]);
	}
	x = 0;
	/*for (x; x < rozmiar_tablicy; x++)
	{
		printf("wyniki ostateczne:%lf\n", tab_szum_wlasciwa[x]);
	}*/
}

void filtr_srednia_ruchoma(double* tab_szum_wlasciwa, double* wyniki_po_sredniej, int rozmiar_tablicy)
{
	double tab[5];

	wyniki_po_sredniej[0] = tab_szum_wlasciwa[0];         //przepisanie dwoch pierwszych i ostatnich wyrazow tabeli do tabeli przefiltrowanych danych
	wyniki_po_sredniej[1] = tab_szum_wlasciwa[1];
	wyniki_po_sredniej[rozmiar_tablicy - 1] = tab_szum_wlasciwa[rozmiar_tablicy - 1];
	wyniki_po_sredniej[rozmiar_tablicy - 2] = tab_szum_wlasciwa[rozmiar_tablicy - 2];

	for (int j = 2; j < rozmiar_tablicy - 2; j++)         //j=2 bo olewamy pierwsze dwa przepisane wczesniej miejsca
	{
		tab[0] = tab_szum_wlasciwa[j - 2];        //przypisujemy wartosci do tablicy ktora potem sortujemy babelkowo
		tab[1] = tab_szum_wlasciwa[j - 1];
		tab[2] = tab_szum_wlasciwa[j];
		tab[3] = tab_szum_wlasciwa[j + 1];
		tab[4] = tab_szum_wlasciwa[j + 2];
		wyniki_po_sredniej[j] = (tab[0] + tab[1] + tab[2] + tab[3] + tab[4]) / 5;
		printf("wynik po sredniej: %lf\n", wyniki_po_sredniej[j]);
		printf("tab_wartosci=%lf", tab_szum_wlasciwa[j - 2]);
	}


}

void filtr_medianowy(double* tab_szum_wlasciwa, double* wyniki_po_medianowym, int rozmiar_tablicy) {

	double tab[5];
	double tab_2[5];
	double a;
	int i;
	int szerokosc_okna_filtra;

	wyniki_po_medianowym[0] = tab_szum_wlasciwa[0];         //przepisanie dwoch pierwszych i ostatnich wyrazow tabeli do tabeli przefiltrowanych danych
	wyniki_po_medianowym[1] = tab_szum_wlasciwa[1];
	wyniki_po_medianowym[rozmiar_tablicy - 1] = tab_szum_wlasciwa[rozmiar_tablicy - 1];
	wyniki_po_medianowym[rozmiar_tablicy - 2] = tab_szum_wlasciwa[rozmiar_tablicy - 2];

	for (int j = 2; j < rozmiar_tablicy; j++)         //j=2 bo olewamy pierwsze dwa przepisane wczesniej miejsca
	{
		tab[0] = tab_szum_wlasciwa[j - 2];        //przypisujemy wartosci do tablicy ktora potem sortujemy babelkowo
		tab[1] = tab_szum_wlasciwa[j - 1];
		tab[2] = tab_szum_wlasciwa[j];
		tab[3] = tab_szum_wlasciwa[j + 1];
		tab[4] = tab_szum_wlasciwa[j + 2];

		szerokosc_okna_filtra = 4;
		do {
			for (i = 0; i < szerokosc_okna_filtra; i++)      // i cyk sortowanie babelkowe
			{
				if (tab[i] > tab[i + 1])
				{
					a = tab[i + 1];
					tab[i + 1] = tab[i];
					tab[i] = a;
				}
			}
			szerokosc_okna_filtra--;
		} while (szerokosc_okna_filtra > 1);
		wyniki_po_medianowym[j] = tab[2];
	}
	for (int x = 0; x < rozmiar_tablicy; x++)
		printf("wynik po medianowym: %lf\n", wyniki_po_medianowym[x]);		//sprawdzenie dzialania
}
