#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <locale.h>

void wczytywanie_wspolczynnikow(double tab_wspolczynniki[], int ilosc_wspolczynnikow);
void dziedzina(double* dziedzina_minimum, double* dziedzina_maksimum);
void generatorSinus(double tab_wspolczynniki[], int rozmiar_tablicy, double tab_wartosci[], int* ilosc, double* rozdzielczosc, double* dziedzina_minimum, double *tab_szum_wlasciwa, double* wyniki_po_filtrze);
void rozmiar_tablic(int* rozmiar_tablicy);
void zapisz(double* tab_wartosci, double* tab_szum_wlasciwa, int* rozmiar_tablicy, double* wyniki_po_filtrze);
void szum(double tab_wartosci[], int rozmiar_tablicy, double wyniki_szumu[], double tab_szum_wlasciwa[], double* wyniki_po_filtrze);
void filtr_srednia_ruchoma(double* tab_szum_wlasciwa, double* wyniki_po_sredniej, int rozmiar_tablicy,double* wyniki_po_filtrze);
void filtr_medianowy(double* tab_szum_wlasciwa, double* wyniki_po_medianowym, int rozmiar_tablicy, double* wyniki_po_filtrze);

void sawSignal(float tab_wspolczynniki[], float dziedzina_minimum, float dziedzina_maksimum, float tab_wartosci[], int* ilosc, float* rozdzielczosc) {
	float coefficentA = tab_wspolczynniki[0];
	float coefficentB = tab_wspolczynniki[1];
	float waveLenght = tab_wspolczynniki[2];
	float currentValue = coefficentB;
	float amplitude = coefficentA;
	float j = 0;
	int i = 0;
	int x = 0;
	int y = 0;



	for (j = dziedzina_minimum; j <= (dziedzina_maksimum - dziedzina_minimum) * (1 / (*rozdzielczosc)); j = j + 1) {
		*(tab_wartosci + i) = currentValue;
		*ilosc = (*ilosc) + 1; //ilosc to ilosc wynikow
		printf("%d, ", *ilosc);   //sprawdzenie ilosci zapelnionych komorek
		printf("j=%f,", j); // sprawdzenie jak sie j nalicza
		printf("  i=%d    wartosc to: %f  [%d]		granica=%f\n", i, currentValue, x, dziedzina_maksimum);
		x++;
		i++;
		currentValue = currentValue + *rozdzielczosc;
		if (currentValue > amplitude) {
			currentValue = coefficentB;
		}
	}
	*(tab_wartosci + i) = '\0';
}

void otwarcie_pliku(double* tab_wartosci, double* tab_szum_wlasciwa, int *rozmiar_tablicy)
{
	double pierwsza_liczba;
	double druga_liczba;
	int nowy_rozmiar;
	nowy_rozmiar = 1;

	{
		double pierwsza_liczba, druga_liczba;
		FILE* plik = fopen("Wyniki.CSV", "r");
		if (plik)
		{
			while (fscanf(plik, "%lf;%lf", &pierwsza_liczba, &druga_liczba) == 2) {	//==2 oznacza, ze jezeli udalo sie wczytac dokladnie 2 elementy
				printf("%lf -> %lf\n", pierwsza_liczba, druga_liczba);
				tab_wartosci = realloc(tab_wartosci, nowy_rozmiar * sizeof(*tab_wartosci));	//zwraca wskaznik tablicy o realokowanym rozmiarze, jako parametr przyjmuje: tablice(adres) ktorą ma realokowac,na jaki rozmiar ma zmienic(tutaj wartosc)
				tab_szum_wlasciwa = realloc(tab_szum_wlasciwa, nowy_rozmiar * sizeof(*tab_szum_wlasciwa));
				tab_wartosci[nowy_rozmiar - 1] = pierwsza_liczba;
				tab_szum_wlasciwa[nowy_rozmiar - 1] = druga_liczba;
				printf("tab_wartosci: %lf	tab_szum_wlasciwa:%lf\n", tab_wartosci[nowy_rozmiar - 1], tab_szum_wlasciwa[nowy_rozmiar - 1]);

			}
			fclose(plik);
			*rozmiar_tablicy = nowy_rozmiar;

		}
		else printf("Ups, cos nie dziala! Nie udalo sie otworzyc pliku CSV. Sprawdz kod i sprobuj zresetowac program\n");
		return 0;
	}
}





int main() {
	setlocale(LC_ALL, "polish_poland");
	double tab_wspolczynniki[4];
	int ilosc_wspolczynnikow = 4; //zmienic w zaleznosci od potrzeb

	/*
	WSPOLCZYNNIKI
	[0]-WSPOLCZYNNIK A- AMPLITUDA		A*sin(C*alfa+D)+B
	[1]-WSPOLCZYNNIK B
	[2]-CZESTOTLIWOSC
	[3]-FAZA
	*/

	double dziedzina_minimum;
	double dziedzina_maksimum;
	dziedzina(&dziedzina_minimum, &dziedzina_maksimum);								// FUNKCJA

	int rozmiar_tablicy;
	rozmiar_tablic(&rozmiar_tablicy);		//wpisujemy rozmiar tablicy

	double rozdzielczosc = (fabs(dziedzina_minimum) + fabs(dziedzina_maksimum)) / rozmiar_tablicy;  //fabs zwraca wartosc bezwzgledna
	printf("rozdzielczosc to: %lf\n\n", rozdzielczosc);

	double* tab_wartosci = malloc(rozmiar_tablicy * sizeof(*tab_wartosci)); //float ma 4 bajty*rozmiar tablicy i przydzielamy malloc'iem to tab_wartosci
	double* tab_szum = malloc(rozmiar_tablicy * sizeof(*tab_szum));
	double* tab_szum_wlasciwa = malloc(rozmiar_tablicy * sizeof(*tab_szum_wlasciwa));		//tutaj jest tablica wartosci, z dodanym szumem
	double* wyniki_po_sredniej = malloc(rozmiar_tablicy * sizeof(*wyniki_po_sredniej));
	double* wyniki_po_medianowym = malloc(rozmiar_tablicy * sizeof(*wyniki_po_medianowym));
	double* wyniki_po_filtrze = malloc(rozmiar_tablicy * sizeof(*wyniki_po_filtrze));


	double* tab_odfiltrowane = malloc(rozmiar_tablicy * sizeof(*tab_wartosci));


	int ilosc_zapelnionych_komorek = 0;		//tutaj jest do liczenia zapelnionych komorek
	//wczytywanie_wspolczynnikow(tab_wspolczynniki, ilosc_wspolczynnikow);			//FUNKCJA

	tab_wspolczynniki[0] = 1;
	tab_wspolczynniki[1] = 0;
	tab_wspolczynniki[2] = 1;
	tab_wspolczynniki[3] = 0;

	//sawSignal(tab_wspolczynniki, dziedzina_minimum, dziedzina_maksimum, tab_wartosci, &ilosc_zapelnionych_komorek,&rozdzielczosc);				//FUNKCJA
	generatorSinus(tab_wspolczynniki,rozmiar_tablicy, tab_wartosci, &ilosc_zapelnionych_komorek, &rozdzielczosc,&dziedzina_minimum,tab_szum_wlasciwa,wyniki_po_filtrze);			//FUNKCJA
	
			
	
	szum(tab_wartosci, rozmiar_tablicy, tab_szum,tab_szum_wlasciwa,wyniki_po_filtrze);
	filtr_srednia_ruchoma(tab_szum_wlasciwa,wyniki_po_sredniej,rozmiar_tablicy, wyniki_po_filtrze);
	filtr_medianowy(tab_szum_wlasciwa, wyniki_po_medianowym, rozmiar_tablicy, wyniki_po_filtrze);
	zapisz(tab_wartosci,tab_szum_wlasciwa, &rozmiar_tablicy,wyniki_po_filtrze);
	//otwarcie_pliku(tab_wartosci, tab_szum_wlasciwa, &rozmiar_tablicy);

	return 0;
}


//////////////  FUNKCJE  //////////////

void wczytywanie_wspolczynnikow(double tab_wspolczynniki[], int ilosc_wspolczynnikow) {
	int a = 0;
	int c;
	for (a; a < ilosc_wspolczynnikow; a++) {
		printf("Podaj %d wspolczynnik (A*sin(C*alfa+D)+B):", a + 1);
		while (scanf("%lf", tab_wspolczynniki + a) != 1) {
			printf("podaj prawidlowa liczbe!");
			while ((c = getchar()) != '\n' && c != EOF) {}
		}
	}

	/* for(a=0;a<ilosc_wspolczynnikow;a++){
	 printf("\n%d wspolczynnik to:%f",a+1,tab_wspolczynniki[a]);     //test
	 }*/

}

void dziedzina(double* dziedzina_minimum, double* dziedzina_maksimum)
{
	printf("Podaj dolna granice dziedziny: ");
	while (scanf("%lf", dziedzina_minimum) != 1) {
		printf("podaj prawidlowa liczbe!");
		int c;
		while ((c = getchar()) != '\n' && c != EOF) {}
	}
	//*dziedzina_minimum = (*dziedzina_minimum) * 10;

	printf("Podaj gorna granice dziedziny: ");
	do {
		while (scanf("%lf", dziedzina_maksimum) != 1) {
			printf("podaj prawidlowa liczbe!");
			int c;
			while ((c = getchar()) != '\n' && c != EOF) {}
		}
		//	*dziedzina_maksimum = (*dziedzina_maksimum) * 10;
		if (*dziedzina_maksimum > * dziedzina_minimum) {
			printf("dolna granica to:%lf\ngorna granica to:%lf\n\n\n", (*dziedzina_minimum), (*dziedzina_maksimum));
		}
		else { printf("gorna granica musi byc wieksza od dolnej!\nPodaj gorna granice dziedziny:"); }

	} while (*dziedzina_maksimum <= *dziedzina_minimum);
}

void generatorSinus(double wspolczynniki[], int rozmiar_tablicy, double tab_wartosci[], int* ilosc, double* rozdzielczosc, double* dziedzina_minimum, double* tab_szum_wlasciwa, double* wyniki_po_filtrze) {
	double parametrA = wspolczynniki[0]; //amplituda
	double parametrB = wspolczynniki[1];
	double parametrC = wspolczynniki[2]; //czestotliwosc
	double parametrD = wspolczynniki[3];
	int j;
	int i = 0;
	double x;

	for (j = 0; j < rozmiar_tablicy; j = j++) {
		x = *dziedzina_minimum + (j * (*rozdzielczosc));	//x to jeden krok, zaczynajacy sie od dziedziny
		tab_wartosci[j] = parametrA * sinf((parametrC * x) + parametrD) + parametrB;  
		tab_szum_wlasciwa[j] = parametrA * sinf((parametrC * x) + parametrD) + parametrB;
		wyniki_po_filtrze[j] = parametrA * sinf((parametrC * x) + parametrD) + parametrB;
				//SPRAWDZENIA
		*ilosc = (*ilosc) + 1; //ilosc to ilosc wynikow, ile razy petla sie zrobila
		 //printf("%d, ", *ilosc);   //sprawdzenie ilosci zapelnionych komorek
		//printf("j=%lf,", j); // sprawdzenie jak sie j nalicza
		//printf("  j=[%d]    wartosc z generatora to: %lf \n", j, wyniki_po_filtrze[j]);	//*/
		

	}
}

void rozmiar_tablic(int* rozmiar_tablicy)
{
	printf("Podaj liczbe elementow funkcji: ");
	scanf("%d", rozmiar_tablicy);
	while (*rozmiar_tablicy < 0 || *rozmiar_tablicy == 0)				// ZABEZPIECZENIA DOROBIC
	{
		printf("Wprowadziles niepoprawna liczbe podaj liczbe > 0. Liczba elementow funkcji: ");
		scanf("%d", rozmiar_tablicy);
	}
}

void zapisz(double* tab_wartosci, double* tab_szum_wlasciwa, int* rozmiar_tablicy, double* wyniki_po_filtrze) {
	FILE* plik;
	int j = 0;

	plik = fopen("Wyniki.CSV", "w");

	if (plik == NULL)
	{
		printf("Ups, cos nie dziala! Nie udalo sie otworzyc pliku CSV. Sprawdz kod i sprobuj zresetowac program\n");
	}
	for (j; j < *rozmiar_tablicy; j++) {
		fprintf(plik, "%d;%lf;%lf;%lf\n", j, tab_wartosci[j], tab_szum_wlasciwa[j], wyniki_po_filtrze[j]);
	}

	fclose(plik);
}

void szum(double tab_wartosci[], int rozmiar_tablicy, double wyniki_szumu[], double tab_szum_wlasciwa[], double* wyniki_po_filtrze)
{
	srand(time(NULL));
	int liczba_zaszumionych;
	int max = (0.21 * rozmiar_tablicy);                  //gorna granica losowania
	int min = (0.1 * rozmiar_tablicy);                   //dolna granica losowania

	liczba_zaszumionych = (rand() % max + min);	// losuje od 0 do (max-1), a do tego dodaje wartosc min
	printf("Liczba zaszumionych probek = %d\n", liczba_zaszumionych);

	double amplituda;
	double najwieksza = tab_wartosci[0];              //ustalamy, że największą wartością jest (póki co) pierwszy element tablicy
	double najmniejsza = tab_wartosci[0];             //ustalamy, że najmniejszą wartością jest (póki co) pierwszy element tablicy
	

	for (int i = 0; i < rozmiar_tablicy; i++)         //szukanie amplitudy
	{
		if (tab_wartosci[i] > najwieksza)
			najwieksza = tab_wartosci[i];                 //jeśli sprawdzany element tablicy jest większy od tego (dotychczas) największego, to on staje się tym największym

		if (tab_wartosci[i] < najmniejsza)
			najmniejsza = tab_wartosci[i];               //jeśli sprawdzany element tablicy jest mniejszy od tego (dotychczas) najmniejszego, to on staje się tym najmniejszym
	}

	amplituda = fabs(najwieksza) + fabs(najmniejsza);

	printf("Najwieksza wartosc funkcji to: %lf\n", najwieksza);
	printf("Najmniejsza wartosc funkcji to: %lf\n", najmniejsza);
	printf("Amplituda wynosi: %lf\n", amplituda);
	int x = 0;
	for (x; x < rozmiar_tablicy; x++) {
		tab_szum_wlasciwa[x] = tab_wartosci[x];		//przerzucenie wynikow do drugiej tablicy, do ktorej potem jest dodawany szum
	}

	int i2;
	double wartosc_szumu;
	int max_szum = 31 * amplituda * 2;
	int min_szum = -31 * amplituda;
	int numer_tablicy;
	//printf("max_szum=%d, min_szum=%d\n", max_szum, min_szum);
	//printf("\n\n\n\n\n\n");
	for (i2 = 0; i2 < liczba_zaszumionych; i2++)
	{
		numer_tablicy = (rand() % rozmiar_tablicy + 1);
		wartosc_szumu = (rand() % max_szum / 100. + min_szum / 100.);
		wyniki_szumu[numer_tablicy] = wartosc_szumu;
		//printf("wynik szumu:%lf\n", wyniki_szumu[numer_tablicy]);
		tab_szum_wlasciwa[numer_tablicy] = wyniki_szumu[numer_tablicy] + tab_wartosci[numer_tablicy];	//dodanie szumu do tablicy
			//printf("\nwyniki po zaszumieniu to:%lf\n", tab_szum_wlasciwa[numer_tablicy]);
	}
	for (int i3 = 0; i3 < rozmiar_tablicy; i3++)
	{
		wyniki_po_filtrze[i3] = tab_szum_wlasciwa[i3];
	}
	/*x = 0;
	for (x; x < rozmiar_tablicy; x++)
	{
		printf("[%d]tab_wartosci ostateczne:%lf\n",x ,tab_szum_wlasciwa[x]);
	}		//*/
}

void filtr_srednia_ruchoma(double* tab_szum_wlasciwa, double* wyniki_po_sredniej, int rozmiar_tablicy,double* wyniki_po_filtrze)
{
	double tab[5];

	wyniki_po_sredniej[0] = tab_szum_wlasciwa[0];         //przepisanie dwoch pierwszych i ostatnich wyrazow tabeli do tabeli przefiltrowanych danych
	wyniki_po_sredniej[1] = tab_szum_wlasciwa[1];
	wyniki_po_sredniej[rozmiar_tablicy - 1] = tab_szum_wlasciwa[rozmiar_tablicy - 1];
	wyniki_po_sredniej[rozmiar_tablicy - 2] = tab_szum_wlasciwa[rozmiar_tablicy - 2];

	for (int j = 2; j < rozmiar_tablicy - 2; j++)         //j=2 bo olewamy pierwsze dwa przepisane wczesniej miejsca
	{
		tab[0] = tab_szum_wlasciwa[j - 2];        //przypisujemy wartosci do tablicy ktora potem sortujemy babelkowo
		tab[1] = tab_szum_wlasciwa[j - 1];
		tab[2] = tab_szum_wlasciwa[j];
		tab[3] = tab_szum_wlasciwa[j + 1];
		tab[4] = tab_szum_wlasciwa[j + 2];
		wyniki_po_sredniej[j] = (tab[0] + tab[1] + tab[2] + tab[3] + tab[4]) / 5;
		
	}
	//for (int x = 0; x < rozmiar_tablicy;x++)	printf("[%d]wynik po sredniej: %lf\n", x, wyniki_po_sredniej[x]);
	for (int i3 = 0; i3 < rozmiar_tablicy; i3++)
	{
		wyniki_po_filtrze[i3] = wyniki_po_sredniej[i3];
	}


}

void filtr_medianowy(double* tab_szum_wlasciwa, double* wyniki_po_medianowym, int rozmiar_tablicy, double* wyniki_po_filtrze) {

	double tab[5];
	double tab_2[5];
	double a;
	int i;
	int szerokosc_okna_filtra;

	wyniki_po_medianowym[0] = tab_szum_wlasciwa[0];         //przepisanie dwoch pierwszych i ostatnich wyrazow tabeli do tabeli przefiltrowanych danych
	wyniki_po_medianowym[1] = tab_szum_wlasciwa[1];
	wyniki_po_medianowym[rozmiar_tablicy - 1] = tab_szum_wlasciwa[rozmiar_tablicy - 1];
	wyniki_po_medianowym[rozmiar_tablicy - 2] = tab_szum_wlasciwa[rozmiar_tablicy - 2];

	for (int j = 2; j < rozmiar_tablicy-2; j++)         //j=2 bo olewamy pierwsze dwa przepisane wczesniej miejsca
	{
		tab[0] = tab_szum_wlasciwa[j - 2];        //przypisujemy wartosci do tablicy ktora potem sortujemy babelkowo
		tab[1] = tab_szum_wlasciwa[j - 1];
		tab[2] = tab_szum_wlasciwa[j];
		tab[3] = tab_szum_wlasciwa[j + 1];
		tab[4] = tab_szum_wlasciwa[j + 2];

		szerokosc_okna_filtra = 4;
		do {
			for (i = 0; i < szerokosc_okna_filtra; i++)      // i cyk sortowanie babelkowe
			{
				if (tab[i] > tab[i + 1])
				{
					a = tab[i + 1];
					tab[i + 1] = tab[i];
					tab[i] = a;
				}
			}
			szerokosc_okna_filtra--;
		} while (szerokosc_okna_filtra > 1);
		wyniki_po_medianowym[j] = tab[2];
	}
	//for (int x = 0; x < rozmiar_tablicy; x++)	printf("wynik po medianowym[%d]: %lf\n", x,wyniki_po_medianowym[x]);		//sprawdzenie dzialania

	for (int i3 = 0; i3 < rozmiar_tablicy; i3++)
	{
		wyniki_po_filtrze[i3] = wyniki_po_medianowym[i3];
	}
}

